

# HTML

## 标签语法

`<xxx>`开始标签，`<>`里面是标签名

`</xxx>`结束标签，比开始标签多`/`



双标签：成对出现的标签

单标签：只有开始标签，没有结束标签。不需要包裹内容

## HTML基本骨架

```html
<!doctype html>
<html>
	<head>
		<title>网页标题</title>
		…………
	</head>
	<body>
		xxx
	</body>
</html>
```

html标签内是整个网页的内容

head标签：网页头部，存放给浏览器使用的代码，如CSS

body标签：网页主体，存放给用户看的代码，如图片，文字

title标签：网页的标题

## 标签的关系

### 父子关系/嵌套关系

一个标签在另一个标签的内部

### 兄弟关系/并列关系

标签之间是并列的，互不干扰

vsc缩进快捷键tab，取消缩进快捷键shift+tab

## 注释格式

`<!--注释内容-->`注释不会在浏览器显示

vsc添加/删除注释快捷键ctrl+/

## 标题标签

一般用在新闻标题，文章标题，网页区域名称，产品名称等。

`<h1>-<h6>`六个等级的标题，都是双标签

> [!TIP]
>
> （。＾▽＾）
>
> h1标签在一个网页中只能用一次，用来放新闻标题或网页的logo等最重要的东西

## 段落标签

`<p>xxx</p>`

特性：

- 独占一行
- 段落间存在间隙

## 换行标签

`<br>`单标签。

浏览器不识别代码中的回车换行

## 水平线标签

`<hr>`单标签

## 文本格式化标签

给文本加入特殊格式，以突出重点

常见的文本格式有：**加粗**，*倾斜*，<u>下划线</u>，~~删除线~~等



 `<strong>xxx</strong>`加粗，或者`<b></b>`（非常用）

`<em>xxx</em>`倾斜，或者`<i></i>`（非常用）

`<ins>xxx</ins>`下划线，或者`<u></u>`（非常用）

`<del>xxx</del>`删除线，或者`<s></s>`（非常用）

## 图像标签

在网页中插入图片

基本格式：

```html
<img src="图片的url" alt="xxx"> //单标签，src指定图像的位置
```

其他属性：

alt:图片无法显示的时候显示的文字
title：鼠标定在图片上面时显示的文字
width：图片的宽度，值为数字，没有单位
height：图片的高度，值为数字，没有单位

**属性之间空格隔开**

> [!NOTE]
>
> o(*￣▽￣*)o
>
> ./表示当前路径（可省略）
>
> ../表示上一级路径
>
> 一般用相对路径，绝对路径一般用于使用网址表示路径

## 超链接标签

点击跳转到其他页面

基本格式：

```html
<a href="xxx">yyy</a> //yyy是显示的内容
```

href：跳转的地址，是必需的属性

> [!TIP]
>
> 开发初期，不知道超链接的跳转地址，href属性值写#，表示空连接，不会进行跳转

其他属性：

target:使用`target="_blank"`可以实现新窗口打开链接

## 音频标签

基本格式：

```html
<audio src="xxx"></audio>
```

其他属性：

controls：显示音频的控制面板（没有=""，因为在html5里，当属性名和属性值相同时，就不需要=""）

loop：循环播放（没有=""，因为在html5里，当属性名和属性值相同时，就不需要=""）

autoplay：自动播放（为了用户体验，一般不自动播放）（没有=""，因为在html5里，当属性名和属性值相同时，就不需要=""）

## 视频标签

基本格式：

```html
<video src="xxx"></video> //支持格式：MP4,WebM,Ogg
```

其他属性：

controls：显示视频的控制面板

loop：循环播放

muted：静音播放

autoplay：自动播放（浏览器支持在静音模式下自动播放）

## 网页制作思路

从上到下，从整体到局部

## 列表标签

布局内容排列整齐的区域

分为三类：无序列表，有序列表，定义列表（一个标题下有多个内容）

### 无序列表

```html
<ul>
	<li>xxx</li>
	<li>xxx</li>
	…………
</ul>
```

### 有序列表

```html
<ol>
	<li>xxx</li>
	<li>xxx</li>
	…………
</ol>
```

### 定义列表

```html
<dl>
	<dt>yyy</dt>
	<dd>xxx<dd>
	<dd>xxx<dd>
</dl>
```

dl是定义列表本体

dt是定义列表的标题

dd是定义列表的详情

## 表格标签

用于展示数据

```html
<table border="xxx">
	<thead>
		<tr>
			<th>姓名</th>
			<th>学号</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>张三</td>
			<td>01</td>
		</tr>
		<tr>
			<td>李四</td>
			<td>02</td>
		</tr>
	<tbody>
	<tfoot>
	</tfoot>
</table>
```

table是表格本体

tr是行

th是表头单元格

td是内容单元格



其他属性：

border：显示单元格边框，值为数字，没有单位

### 表格结构标签

把内容划分区域，让浏览器能够知道区域信息



thead:表格头部

tbody：表格主体

tfoot：表格底部

### 合并单元格

行合并和列合并。

步骤：

1.保留最左最上的单元格，在`<td>`中添加属性，值为数字，表示需要合并的单元格数量（要数自身）

- 行合并，保留最上单元格，属性名为`rowspan`
- 列合并，保留最左单元格，属性名为`colspan`

2.删除其他单元格

> [!CAUTION]
>
> （＞人＜；）
>
> 合并单元格不能跨结构

## 表单

用于收集用户信息

使用场景：

- 登陆页面
- 注册页面
- 搜索区域

### input标签

基本格式：

```html
<input type="xxx"> //单标签
```

input标签的type属性值不同，则功能不同。

属性：

- text：文本框，用于输入**单行**文本
  - placeholder：占位文本，用于提示
- password：密码框
- radio：单选框
  - name：分组，同组只能选中一个
  - checked：默认选中，无=""
- checkbox：多选框
  - checked：默认选中，无=""
- file：上传文件
  - multiple：实现文件多选，无=""



例子：

```html
<body>
	用户名：<input type="text" placeholder="输入用户名">
	<br>
	<br>
	密码：<input type="password" placeholder="输入密码">
	<br>
	<br>
	性别：<input type="radio" name="gender" checked>男 <input type="radio" name="gender">女
	<br>
	<br>
	是否同意用户协议：<input type="checkbox">
	<br>
	<br>
	上传文件：<input type="file">
</body>
```

### 下拉菜单

```html
<body>
    城市：
    <select>
        <option>重庆</option>
        <option>深圳</option>
        <option selected>广州</option>
    </select>
</body>
```

select:下拉菜单整体

option：下拉菜单的每一项



其他属性：

selected：默认选中，无=""

### 文本域标签

用于多行输入文本，文本会自动换行

```html
<textarea>默认提示文字</textarea>
```

> [!WARNING]
>
> (￣ ‘i ￣;)
>
> 要禁用拖拽放缩功能，且用CSS设置尺寸

### label标签

用于某个标签的说明文本

> [!TIP]
>
> (　o=^•ェ•)o　┏━┓
>
> 用label标签绑定文字和表单控件的关系后，**可增大表单控件的点击范围**

- 写法一：
  - label标签只包裹内容，不包裹表单控件
  - 设置label标签的for属性值和表单控件的id属性值相同

```html
<input type="radio" id="man"><lable for="man">男</lable>
```



- 写法二：
  - 使用label标签包裹文字和表单控件，不需要属性

```html
<label><input type="radio">女</label>
```

### 表单区域标签

将表单控件分隔成一个个区域，方便整体发送数据或者其他操作

```html
<form>
	xxx
</form>
```

 其他属性：

action：发送数据的地址

### 按钮标签

```html
<button type="xxx">登录</button>
```

button标签的type属性值不同，则功能不同。

属性：

- submit：提交按钮，点击后将数据提交给后台（默认功能）
- reset：重置按钮，点击后将表单区域中的表单控件恢复默认值，需要配合表单区域标签
- button：普通按钮，没有功能，配合JavaScript使用

## 无语义的布局标签

用于划分网页区域，拜访内容

### div：独占一行

`<div>xxx</div>`

称为大盒子

### span：不换行

`<span>xxx</span>`

称为小盒子

## 字符实体

用于在网页中显示预留字符

空格：`&nbsp;`

"<":`&lt;`

">":`&gt;`

# CSS

用于美化html，放入`<head></head>`中的`<title></title>`下面

## CSS语句的使用

在HTML中使用link标签引入CSS文件，粘贴到文档头部（也就是`<head>`和`</head>`之间

```html
<link rel="stylesheet" href="styles/xxx.css">
```



行内样式：配合JavaScript使用。CSS写在标签的style属性值里面

```html
<div style="color:red;">xxx</div>
```

## CSS选择器

用于查找标签并设置样式

### 标签选择器

使用**标签名**作为选择器，选中**同名标签**设置相同的样式

比如：

```css
p{
	color:red;
}

li,
h1{
	color:blue;
}
```

### 类选择器

分类，差异化设置标签的显示效果。可叠加使用

步骤：

1. 定义类名
2. 标签中添加class="类名"，类名之间加空格区分

比如：

```css
.x1{
	color:red;
}
.x2{
	font-size:50px;
}
------------html中--------------
<div class="x1 x2">yyy</div>
```

> [!TIP]
>
> (～﹃～)~zZ
>
> 类名要见名知意，多个单词用-链接

### id选择器

分类，差异化设置标签的显示效果。**一般配合JavaScript使用**

步骤：

1. 定义id
2. 标签中添加id="id名"

比如：

```css
#x1{
	color:red;
}

------------html中--------------
<div id="x1 x2">yyy</div>
```

> [!CAUTION]
>
> ＞﹏＜
>
> 同一个id选择器在一个页面只能使用一次

### 通配符选择器

用于查找页面所有标签，设置相同样式

`*`，不需要调用，浏览器自动查找页面所有标签，设置相同样式

比如：

```css
*{
	color:red;
}
```

可用于清除标签的默认样式

## 盒子的基本属性

使用合适的选择器

属性：

width：宽度

height：高度

background-color：背景颜色

## 文字控制属性

- font-size：字体大小
  - 必须要有单位，常用单位为px
  - 谷歌浏览器文字默认大小为16px
- font-weight：字体粗细
  - 属性值可以是数字（推荐）
    - 正常：400
    - 加粗：700
  - 也可以是关键字：
    - 正常：normal
    - 加粗：bold
- font-style：字体倾斜
  - 正常：normal
  - 倾斜：italic
- line-height：行高
  - 行高由上间距，文本高度，下间距组成。测量方法：一行文字的最顶端到下一行文字的最顶端的长度
  - 属性值可以是数字+px
  - 也可以是数字，表示当前标签font-size属性值的整数倍
  - 垂直居中技巧：行高属性值等于盒子高度属性值。只适用于单行文字
- font-family：字体族
  - 属性值是字体名，如`楷体`
  - 可以写多个字体名，用逗号隔开，从左到右依次查找使用
  - 属性值最后加上一个字体族名，以保持字体统一。建议使用无衬线字体：`sans-serif`
- font：复合属性
  - 设置网页文字公共样式
  - 属性值是其他属性的属性值，用空格隔开，必须按照顺序写：倾斜 加粗 字号/行高 字体
  - 比如`font:normal 700 30px/2 楷体;`
  - 字号和字体值必须有，不然不生效（其他可以不要）
- text-indent：文本缩进
  - 属性值可以是数字+px
  - 也可以是数字+em（1em=当前标签的字号大小，推荐这种）
- text-align：文本对齐，居中的只是标签中的文字/图片，而不是标签
  - left：左对齐（默认）
  - center：居中对齐
  - right：右对齐
- text-decoration：修饰线
  - none：无
  - underline：下划线
  - line-through：删除线
  - overline：上划线
- color：颜色
  - `颜色英文单词`
  - `rgb(r,g,b)`
  - `rgba(r,g,b,a)`a为透明度，取值0-1
  - `#RRGGBB`16进制表示法，两两一组，若相同则可以缩写成一个

## 调试工具

### 打开

- 浏览器中鼠标右键->检查
- F12

### 使用

如果是错误的属性，有黄色叹号

在CSS属性钱有多选框，如果勾选，说明这个属性生效

## 复合选择器

由多个基础选择器组合而成，可以更准确，更高效的选择目标元素

### 后代选择器

选中某元素的后代元素

基本格式：

`父选择器 子选择器{`

​	`CSS属性;`

`}`

父子选择器之间用空格隔开

比如：

```css
div span{
	color:red;
}

------------html中--------------
<span>xxx</span>//不受影响
<div>
	<span>xxx1</span>//受影响
	<p>
		<span>xxx2</span>//也受影响
	</p>
</div>
```

#### 子代选择器

只选择子代一级

基本格式：

`父选择器 > 子选择器{`

​	`CSS属性;`

`}`

### 并集选择器

选择多组标签设置相同的样式

基本格式：

`选择器1,选择器2,选择器3{`

​	`CSS属性;`

`}`

选择器之间用逗号隔开

比如：

```css
div,
p,
span{
	color:red;
}
```

### 交集选择器

选中同时满足多个条件的元素

基本格式：

`选择器1选择器2选择器3{`

​	`CSS属性;`

`}`

选择器之间连写

> [!CAUTION]
>
> ￣へ￣
>
> 如果有标签选择器，则标签选择器必须写在最前面

比如：

```css
p.box{
	color:red;
}
------------html中--------------
<p class="box">xxx</p>
```

### 伪类选择器

伪类的意思是元素状态，用于选中元素的某个状态设置样式

#### 鼠标悬停状态：

基本格式：

`选择器:hover{`

​	`CSS属性;`

`}`

比如：

```css
a:hover{
	color:red;
}
------------html中--------------
<a href="#">xxx</a>
```

#### 超链接的四个状态

`:link`访问前

`:visited`访问后

`:hover`鼠标悬停

`:active`点击时（激活）

> [!NOTE]
>
> =￣ω￣=
>
> 如果要给超链接设置以上状态，需要按照LVHA的顺序来写，否则不生效

## CSS特性

用于化简代码，定位问题

### 继承性

**子级**默认继承**父级**的**文字控制属性**，标签自己单独设置了的样式，就不会继承父级的（其他没单独设置的会）

工作中一般将文字控制属性设置给body标签

### 层叠性

相同的属性会覆盖：后面的CSS属性覆盖前面的CSS属性

不同的属性会叠加：不同的CSS属性都生效

比如：

```css
div{
	color:red;
	font-weight:700;//叠加
}
div{
	color:green;//最终生效
	font-size:30px;//叠加
}
```

### 优先级

当一个标签使用了多种选择器时，基于不同种类的选择器的匹配规则

优先级高的生效。

标签的范围越大，优先级越低

!important>行内样式>id选择器>类选择器>标签选择器>通配符选择器



!important使用是加到选择器中的属性行的分号之前

比如：

```css
*{
	color:red !important;
}
```

用于将优先级提到最高，慎用



#### 叠加计算

如果是复合选择器，则需要优先级叠加计算

行内样式（有行内样式就直接生效行内样式）>id选择器个数>类选择器个数>标签选择器个数

从左到右依次比较个数，同一级个数多的优先级高，若个数相同，就继续比较下一级



**!important优先级最高**

**继承的优先级最低**

## Emmet写法

代码的简写方式，输入缩写，vsc会自动生成对应的代码

### HTML

类选择器：标签名.类名。div可以省略标签名

id选择器：标签名#id名。div可以省略标签名

同级标签：如div+p

父子级标签：如div>p

多个相同标签：如span*3

带内容的标签：如div{内容}

### CSS

大多数简写方式是属性单词的首字母

比如

`w`：width

`w500`：width:500px;

`w500+h500+bcg`：width:500px;

height:200px;

background-color:#fff;

## 背景属性

- 背景色：background-color

- 背景图：background-image(bgi)

  - 实现装饰性的图片效果
  - 属性值为图片的url
  - 背景图默认是平铺效果：复制以填满

- 背景图平铺方式：background-repeat(bgr)

  - 不平铺：no-repeat
  - 平铺（默认）：repeat
  - 水平方向平铺：repeat-x
  - 竖直方向平铺：repeat-y

- 背景图位置：background-position(bgp)

  - 属性值为水平方向位置 垂直方向位置（用空格隔开）

  - 可以是英文关键字

    - 左侧：left
    - 右侧：right

    

    - 居中：center

    

    - 顶部：top
    - 底部：bottom

  - 也可以是坐标（数字+px，正负都可以）

    - 0 0表示左上角

  - 可以混用。

  - 英文关键字写法可以颠倒取值顺序。

  - 可以只写一个值，另一个方向默认居中

- 背景图缩放：background-size(bgz)

  - 设置背景图大小
  - **属性值可以是关键字**
    - cover：等比例缩放图片，直到图片的宽和高都大于等于盒子的尺寸，就停止缩放。背景图的部分可能会看不见
    - contain：等比例缩放图片，若图片的宽/高和盒子的尺寸相等，就停止缩放。背景区域的部分可能会空白
  - **也可以是百分比**，根据盒子尺寸计算图片大小
    - 100%：等比例缩放图片直到图片的宽度等于盒子的尺寸
  - 也可以是数字+单位

- 背景图固定：background-attachment(bga)

  - 让背景不随着元素的内容滚动

- 背景复合属性：background(bg)

  - 不区分顺序，属性之间用空格隔开

## 显示模式

显示模式指的是标签的显示方式，用于选择合适的标签摆放内容

### 块级元素

- 独占一行
- **宽度默认是父级的100%**
- 添加宽高属性会生效

比如div

### 行内元素

- 一行可以共存多个
- 尺寸由内容撑开
- 添加宽高属性不会生效

比如span

### 行内块元素

- 一行可以共存多个
- 默认尺寸由内容撑开
- 添加宽高属性会生效

比如img

### 转换显示模式

属性名：`display`

属性值：

block：块级

inline-block：行内块

inline：行内

## 结构伪类选择器

根据元素的结构关系查找元素

基本格式：

`X:first-child`查找第一个X元素

`X:last-child`查找最后一个X元素

`X:nth-child(N)`查找第N个X元素，从1开始

比如：

```css
li:first-child{
	color:red;
}
```



`X:nth-child(公式)`根据元素的结构关系查找多个元素

公式：

偶数标签：2n

奇数标签：2n-1/2n+1

五的倍数的标签：5n

第五个以后的标签：n+5

第五个以前的标签：-n+5

## 伪元素选择器

用于创建虚拟元素，以摆放装饰性的内容

基本格式：

`X::before`在X元素里面的最前面添加一个伪元素

`X::after`在X元素里面的最后面添加一个伪元素



必须设置`content:""`属性，用来设置伪元素的内容，如果没有内容，则引号留空

伪元素默认是行内显示模式

优先级和标签选择器相同

比如：

```css
div{
	w300+h300+bcg;
}
div::before{
	content:"老鼠";
}
div::after{
	content:"大米";
}
------------html中--------------
<div>爱</div>
```

## PxCook像素大厨

是一款切图设计工具软件。支持PSD文件的文字，颜色，距离自动识别。

开发模式可以自动智能识别

设计面板用于手动测量尺寸和颜色

## 盒子模型

用于布局网页，摆放盒子和内容

### 组成

- 内容区域：width&height
- 内边距：padding（内容和盒子边缘之间）
- 边框线：border
- 外边距：margin（盒子外，用于拉开两个盒子之间的距离）

### 边框线

属性名：border(bd)

属性值：边框线粗细 线条样式 颜色（空格隔开，不区分顺序）

线条样式：

solid：实线

dashed：虚线

dotted：点线

比如：

```css
div{
	border:2px solid #000;
}
```

#### 单独设置某方向的边框线

属性名：

border-top(bdt)

border-right(bdr)

border-bottom(bdb)

border-left(bdl)

比如：

```css
div{
	border-top:2px solid #000;
}
```

### 内边距

属性名：padding

或者padding-方位（设置某方向的）



padding的多值写法：**值之间空格隔开**

比如：

```css
div{
	padding:10px;//一个值，四个方向都是10px
	padding:10px 20px 30px 40px;//四个值，顺序为上右下左，顺时针
	padding:10px 40px 80px;//三个值，顺序为上 左右 下
	padding:10px 20px;//两个值，顺序为上下 左右
}	
```

### 尺寸计算

默认情况：盒子尺寸=内容尺寸+border尺寸+内边距尺寸

**若不想要border尺寸+内边距尺寸撑大盒子**

- 手动将内容尺寸减去border尺寸和内边距尺寸
- 使用内减模式，加上属性`box-sizing:border-box;`(推荐)

### 外边距

用于拉开两个盒子之间的距离

属性名：margin

**写法同padding**



外边距不会撑大盒子尺寸

#### 版心居中

将margin的左右值设置为`auto`，并且盒子要有宽度属性

#### 外边距合并

垂直排列的兄弟元素，上下margin会合并，取其中较大值生效

比如：

```css
.one{
	w100+h100+bcg;
	margin-bottom:20px;
}
.two{
	w100+h100+bcg;
	margin-top:40px;//最终合并为40px
}
------------html中--------------
<div class="one">one</div>
<div class="two">two</div>
```

#### 外边距坍塌

父子级的标签，子级添加上margin会出现坍塌现象，会导致父级一起向下移动。

比如：

```css
.fa{
    width: 300px;
    height: 300px;
    background-color: pink;
}
.so{
    width: 100px;
    height: 100px;
    background-color: orange;
    margin-top: 30px;
}
------------html中--------------
<div class="fa">
	<div class="so">son</div>
</div>
```



若想要父级与子级间留距离，解决方法：

- 取消子级的上margin，父级设置padding（推荐）
- 父级设置`overflow：hidden;`
- 父级设置border-top

### 清除标签默认样式

用通配符选择器选择所有标签。

比如：

将内外边距设置为0

```css
*{
	margin:0;
	padding:0;
	box-sizing:border-box;
}
```

去除列表前的`·`

```css
li{
	list-style:none;
}
```

### 元素溢出处理

用于控制溢出元素的内容显示方式

属性名：overflow

属性值：

hidden：溢出隐藏

scroll：溢出滚动，无论是否溢出，都显示滚动条位置

auto：溢出才显示滚动条位置

### 行内元素的内外边距问题

行内元素添加margin和padding没无法改变元素的垂直位置



解决方法：

给行内元素加line-height属性可以改变垂直位置

### 圆角属性

设置元素的外边框为圆角

属性名：border-radius

属性值：

- 数字+px（值是圆角的半径）
  - 多值写法是从左上角开始，顺时针顺序
  - 3值：左上 右上左下 右下
  - 2值：左上右下 右上左下
- 百分比
  - 50%以上不会继续改变

#### 正圆形

给正方形盒子设置圆角属性值为宽高的一半/50%

#### 胶囊

给长方形盒子设置圆角属性值为盒子高度的一半

### 阴影属性

给元素设置阴影效果

属性名：box-shadow

属性值：**x轴偏移量 y轴偏移量** 模糊半径 扩散半径 颜色 内/外阴影 

> [!CAUTION]
>
> （。＾▽＾）
>
> x轴偏移量 y轴偏移量必须要有
>
> 默认是外阴影，内阴影是`inset`

## CSS选择器中书写顺序

1. 盒子模型属性
2. 文字样式
3. 圆角、阴影等修饰属性

## 标准流

也叫文档流，指的是标签在页面中默认的排布规则

比如：

块元素独占一行

行内元素一行显示多个

## 浮动属性（了解）

让块元素水平排列

属性名：float

属性值：

- 左对齐：left
- 右对齐：right


特点：

1. 垂直方向顶对齐
2. 变成行内块显示模式特点
3. 浮动后的盒子不再看作标准流的一员，不会占位
4. 父级宽度不够，浮动的子级会换行



### 清除浮动

因为浮动后会脱离标准流，如果父级没有高度，浮动后的子级无法撑开父级高度

解决方法：清除浮动

1. 额外标签：在父元素内容的最后，添加一个块级元素，类名为`clearfix`，并设置CSS属性`clear:both`

2. 单伪元素法：使用伪元素在父元素内容的最后，添加一个块级元素，类名为`clearfix`

   ```css
   .clearfix::after{
   	content:"";//这个必须要
   	display:block;
   	clear:both;
   }
   ```

3. 双伪元素法（推荐）：

   ```css
   .clearfix::before,
   .clearfix::after{
   	content:"";
   	display:table;
   }
   .clearfix::after{
   	clear:both;
   }
   ```

   after伪元素是用来清除浮动

   before伪元素是用来解决外边距坍塌

4. overflow：父元素添加CSS属性`overflow:hidden;`



## Flex布局（使用）

也叫弹性布局，没有脱标问题

### 组成

给父元素设置`display:flex`，子元素可以自动挤压或拉伸

组成部分：

- 弹性容器：父元素
- 弹性盒子：子元素，**宽高会生效**
- 主轴：默认在水平方向
- 侧轴：默认在垂直方向

### 布局

#### 主轴对齐方式：

属性名`justify-content`

属性值：

`flex-start`默认值，弹性盒子从起点开始以此排序

`flex-end`弹性盒子从终点开始以此排序



`center`弹性盒子沿主轴居中排列

`space-between`弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子之间（父级剩余尺寸来分配成间距）

`space-around`弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子两侧

`space-evenly`弹性盒子沿主轴均匀排列，弹性盒子和容器之间间距相等

#### 侧轴对齐方式

属性名`align-items` 当前弹性容器内所有弹性盒子的侧轴对齐方式（给弹性容器设置）

属性名`align-self`单独控制某个弹性盒子的侧轴对齐方式（给弹性盒子设置）

属性值：

`stretch`弹性盒子沿着侧轴线被拉伸至铺满容器（弹性盒子没有设置侧轴方向尺寸，才能拉伸）

`center`弹性盒子沿侧轴居中排列

`flex-start`弹性盒子从起点开始依次排列

`flex-end`弹性盒子从终点开始依次排列

#### 修改主轴方向

属性名`flex-direction`

属性值：

`row`水平方向，从左向右（默认）

**`column`垂直方向，从上到下**

`row-reverse`水平方向，从右向左

`column-reverse`垂直方向，从下到上

#### 弹性伸缩比

用于控制弹性盒子的主轴方向尺寸

属性名`flex`

属性值：整数，表示占用父级剩余尺寸的份数



默认情况下，主轴方向尺寸靠内容撑开，侧轴拉伸

#### 弹性盒子换行

因为弹性盒子可以自动挤压或拉伸，默认情况下，所有弹性盒子都在一行显示

属性名`flex-wrap`

属性值：

`wrap`换行

`nowrap`不换行（默认）

#### 行对齐方式

属性名`align-content`

属性值：（和主轴对齐方式一样）

`flex-start`默认值，弹性盒子从起点开始依次排列t

`flex-end`弹性盒子从终点开始依次排列



`center`弹性盒子沿主轴居中排列

`space-between`弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子之间（父级剩余尺寸来分配成间距）

`space-around`弹性盒子沿主轴均匀排列，空白间距均分在弹性盒子两侧

`space-evenly`弹性盒子沿主轴均匀排列，弹性盒子和容器之间间距相等

> [!NOTE]
>
> （＞人＜；）
>
> 对单行的盒子不生效

## 项目目录

- images文件夹：放固定使用的图片
- uploads文件夹：放非固定使用的图片
- iconfont文件夹：字体图标素材
- styles文件夹：放css文件
  - base.css 基础公共样式，如清除默认样式，设置网页基本样式（首先link它）
  - common.css各个网页相同模块的重复样式
  - index.css 首页CSS样式
- index.html：首页HTML文件

## 网页制作思路

1. 布局思路：先整体再局部，从外到内，从上到下，从左到右
2. CSS实现思路：
   1. 画盒子，调整盒子范围：宽高背景色
   2. 调整盒子位置：flex布局，内外边距
   3. 控制图片，文字内容样式

## 定位

用于灵活的改变盒子在网页中的位置，比如让一个标签在一个标签之上

### 先加position属性

属性名：position

属性值：

#### `relative`相对定位

特点：

- 改变位置的参照物是自己原来的位置
- 改变后不脱标，会占位
- 标签显示模式特点不会改变



#### `absolute`绝对定位

特点：

- 参照物先找最近的已经定位的祖先元素，若没有找到，就参照浏览器窗口改位置
- 改变后脱标，不占位
- 标签显示模式特点会改变成行内块

**使用场景：子级设置绝对定位，父级设置相对定位**



#### `fixed`固定定位

用于元素的位置在网页滚动时不会改变

特点：

- 参照物是浏览器窗口
- 改变后脱标，不占位
- 标签显示模式特点会改变成行内块的

### 再加方位属性

属性名：top bottom left right

属性值：数字+px



### 定位居中

步骤：

1. 使用绝对定位
2. 水平，垂直 边偏移设置为50%
3. 子级向左，上移动自身尺寸的一半：
   1. 可以将左，上的margin设置为`-尺寸的一半`
   2. 使用`transform:translate(-50%,-50%);`

​	

### 堆叠层级

属性名：z-index

默认效果：按照标签的书写顺序，后来者居上

作用：设置定位元素的层级顺序，改变定位元素的显示顺序

属性值：整数（默认是0，取值越大，显示越靠上层）

## CSS sprites

是一种网页图片应用处理方式。把网页中一些背景图片整合到一张图片文件中，再background-position精确的定位出背景图片的位置

优点：减少服务器被请求次数，减轻服务器的压力，提高页面加载速度

步骤：

1. 创建盒子，盒子尺寸和小图尺寸相同
2. 设置盒子背景图为大图（sprites）
3. 添加background-position属性，改变背景图位置
   1. 使用PxCook测量小图片左上角坐标
   2. **取负数**坐标为background-position属性值（向左上移动图片位置）

## 字体图标

展示的是图标，本质是字体

用于在网页中添加**简单的，颜色单一**的小图标

优点：

1. 灵活性：灵活地修改样式，例如：尺寸，颜色等
2. 轻量级：体积小，渲染快，降低服务器请求次数
3. 兼容性：几乎兼容所有主流浏览器
4. 使用方便：先下载再使用

### 下载字体图标

图标库：https://www.iconfont.cn/

### 使用字体

1.引入字体样式表（iconfont.css）

比如：

```html
<link rel="stylesheet" href="./iconfont/iconfont.css">
```

2.标签使用字体图标类名

​	1.iconfont：字体图标基本样式（字体名，字体大小等）

​	2.icon-xxx：图标对应类名

比如：

```html
<span class="iconfont icon-xxx"></span>
```

> [!CAUTION]
>
> []~(￣▽￣)~*
>
> 如果要调整字体大小，选择器的优先级需要高于iconfont类

### 上传矢量图

将项目特有的图标上传到iconfont图标库，生成字体

## 垂直对齐方式

用于行内块和行内的垂直方向对齐

属性名：vertical-align

属性值：

`baseline`基数对齐（默认）

- 图片底下有空白：可以让图片转成block去除空白，因为浏览器把行内块，行内标签当作文字处理，默认基线对齐
- 其他对齐方式没有空白

`top`顶部对齐，最高内容的顶部

**`middle`居中对齐**

`bottom`底部对齐，最高内容的底部

## 过渡属性

可以为一个元素在**不同状态之间切换**的时候添加过渡效果

属性名：transition（复合属性）

属性值：过渡的属性 花费时间(单位s)（用空格隔开）



过渡的属性可以是具体的CSS属性

也可以为`all`（两个状态中 属性值不相同的所有属性，都产生过渡效果）



transition设置给**元素本身**，而不是状态

## 透明度属性

用于设置整个元素的透明度（包含背景和图片）

属性名：opacity

属性值：0-1

- 0：完全透明
- 1：不透明

## 光标属性

用于指定鼠标悬停在元素上时指针的显示样式

属性名：cursor

属性值：

`default`默认值，通常是箭头

`pointer`小手，提示用户可以点击

`text`工字型，提示用户可以选择文字

`move`十字光标，提示用户可以移动

## 鼠标悬停才显示

将本来元素的display改为none

元素的hover状态中display改为block

## SEO三大标签

搜索引擎优化，提升网站百度搜索排名

方法：

1. 竞价排名
2. 将网页制作成html后缀
3. 标签语义化（使用合适的标签）

网页头部的SEO

- title：网页标题标签
- description：网页描述
- keywords：网页关键词

## Favicon图标

网页图标，出现在浏览器标题栏

命名为：favicon.ico，一般放在网页的根目录里面

比如：

```html
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
```

## 平面转换

又叫做2D转换，用于给元素添加动态效果，一般与过渡配合使用

改变盒子在平面内的形态（位移，旋转，缩放，倾斜）

属性值：transform

### 平移

```css
transform:translate(x轴移动距离，y轴移动距离);
```

取值：

- 数字+px
- 百分比（参照盒子自身尺寸计算结果）
- 正负均可

只写一个值，表示沿着x轴移动

单独设置X或Y轴移动：translateX()或translateY()

#### 平移实现居中

```css
position:absolute;
left:50%;
top:50%;
transform:translate(-50%,-50%);
```

### 旋转

```css
transform:rotate(旋转角度);
```

角度单位是deg

- 取值正负均可
- 取值为正，顺时针旋转
- 取值为负，逆时针旋转

#### 改变转换原点

默认情况下，转换原点是加transform:rotate的盒子的中心点

```css
transform-origin:水平原点位置 垂直原点位置;
```

取值为方位名词

### 多重转换

要先平移再旋转

```css
transform:translate() rotate();
```

因为旋转会改变坐标轴指向

多重转换：以第一种转换形态的坐标轴指向为准

> [!WARNING]
>
> \(￣︶￣*\))
>
> 不能拆开写，因为是相同的属性，会覆盖

### 缩放

```css
transform:scale(缩放倍数);

transform:scale(x轴缩放倍数,y轴缩放倍数);
```

- 一般只设置一个值，表示x轴和y轴等比例缩放
- 取值大于1表示放大，取值小于1表示缩小
- 不需要单位

### 倾斜

```css
transform:skew(角度);
```

角度单位是deg

## 渐变

渐变是多个颜色逐渐变化的效果，一般用于设置盒子背景

### 线性渐变

```css
background-image:linear-gradient(
	渐变方向,
	颜色1 终点位置,
	颜色2 终点位置,
	....
	
);
```

渐变方向可以不加（默认从上到下），取值为：

- `to 方向名词`
- 角度

终点位置可以不加，取值为：

- 百分比

### 径向渐变

用于给按钮添加高光效果

```css
background-image:radial-gradient(
	半径 at 圆心位置,
	颜色1 终点位置,
	颜色2 终点位置,
	....
);
```

半径可以是两条，则为椭圆

圆心位置取值：数字+px/百分比/方位名词

## 空间转换

也叫3D转换

z轴位置和视线方向相同，正数方向指向用户，负数方向指向

屏幕里

属性值：transform

### 平移

```css
transform:translate3d(x,y,z);//必须要三个数
transform:translateX();
transform:translateY();
transform:translateZ();
```

取值：

- 数字+px
- 百分比（参照盒子自身尺寸计算结果）
- 正负均可

### 视距属性

用于指定观察者与z=0平面的距离，为元素添加透视效果

属性名：perspective

透视效果：近大远小，近实远虚



添加给**直接父级**，取值范围800-1200

比如:

```css
.fa{
perspective:1000;
}
-----------html-----------
<div class="fa">
	<div class="son">xxx</div>
</div>
```

### 旋转

```css
transform:rotateX(旋转角度);//取值为正，上边缘往屏幕里
transform:rotateY(旋转角度);//取值为正，右边缘往屏幕里
transform:rotateZ(旋转角度);
```

角度单位是deg

- 取值正负均可
- 旋转法则：**左手法则**，左手握住旋转轴，拇指指向正值方向，其他四个手指弯曲方向为旋转正值方向

#### 拓展

```css
rotate3d(x,y,z,旋转角度);
```

用来自定义旋转轴的位置以及旋转的角度

x，y，z取值为0-1之间的数字

### 立体呈现

设置**元素的子元素**是位于3D空间中还是平面中

属性名：transform-style

属性值：

- `flat`默认值，子级处于平面中
- `preserve-3d`子级处于3D空间

### 缩放

```css
transform:scale3d(x,y,z);
transform:scaleX();
transform:scaleY();
transform:scaleZ();
```

## 动画

实现多个状态间的变化过程，动画过程可控（重复播放）

属性名：animation

实现步骤：

1.定义动画

```css
@keyframes 动画名称{
 from{}//大括号中放的是当前状态的CSS属性
 to{}
}//这种只有两个状态
----------或者------------
@keyframes 动画名称{
	0% {}//百分比表示的是动画时长的百分比
	10% {}
	...
	100% {}
}//这种可以两个以上的状态
```

2.使用动画

```css
animation:动画名称 动画时长 速度曲线 延迟时间 重复次数 动画方向 执行完毕状态;
```

- 动画名称和动画时长必须有
- 不分先后顺序
- 但如果有两个时间值，第一个表示动画时长，第二个表示延迟时间，单位是s

### 速度曲线取值

`linear`匀速运动

`steps(数字)`分步骤运动，用于sprites动画

### 重复次数取值

`数字`，无单位

`infinite`无限重复

### 动画方向取值

`alternate`动画反向

### 执行完毕状态取值

`forwards`让动画停留在结束时的状态

`backwards`不写默认是这个，让动画停留在开始时的状态

### 单独设置

`animation-name`动画名称

`animation-duration`动画时长

`animation-timing-function`速度曲线

`animation-delay`延迟时间

`animation-iteration-count`重复次数

`animation-direction`动画方向

`animation-fill-mode`执行完毕状态

### 暂停动画

`animation-play-state`暂停动画

属性值：

paused为暂停，通常配合`:hover`使用

### 无缝动画原理

复制开头的图片到结尾位置（几张图片的累加宽度=区域宽度，就复制几张）

### 逐帧动画

使用`animation-timing-function:steps(数字)`

用于sprites动画

步骤：

1. 准备显示区域，盒子尺寸和一张sprites小图尺寸相同
2. 定义动画，移动背景图（移动距离=精灵图宽度）
3. 使用动画，steps(N)，N与精灵小图个数相同

### 多组动画

```css
animation:
	动画1,
	动画2,
	...
;
```

当一个动画的开始状态样式和盒子的默认样式相同时，可不写开始状态部分的代码

## 大背景图缩放注意事项

默认转台HTML和body的高度是0，所以导师cover缩放背景图不成功。

所以：

```css
html{
	height:100%;
}
body{
	height:100%;
}
```

# JavaScript

## JavaScript书写位置

外部引入：

```html
<script src="scripts/main.js" defer></script>
```

添加到`</body>` 标签前的新行。



内联写法：

写在标签内部

## 注释风格

和c++一致

## 语句结束符

**用`;`**

但是也可以不写

不过我个人习惯写（c++肌肉记忆）

## 输出语法

1.用于向body内输出内容

```javascript
document.write('xxx');
```

若输出的内容写到是标签，也会被解析成网页元素



比如：

```javascript
document.write('<h1>xxx</h1>');
```

就会输出成h1标签的xxx

2.用于页面弹出警告对话框

```javascript
alert('xxx');
```

3.控制台输出语法，程序员调试使用

```javascript
console.log('xxx');
```

控制台在调试工具里



## 输入语法

```javascript
prompt('xxx');
```

显示一个对话框，xxx是对话框中显示的文字，用来提示用户输入

## 代码执行顺序

按HTML文档流顺序执行JavaScript代码

alert()和prompt()会跳过页面渲染先执行

## 变量

### 变量定义

```javascript
let 变量名;
let a = 10,b = 'pink';
```

### 变量赋值

```javascript
变量名 = xxx;
a = 函数;//可以直接用有返回值的函数赋值
```

- 和c++一样，可以定义的时候赋值
- 不可出现变量重复定义
- 关键字不能作为变量名
- 变量不能以数字开头，只能用下划线，字母，数字，$组成
- 区分大小写
- 起名要有意义，遵循驼峰命令法

### let和var的区别

var有以下问题：

- var可以先使用再定义
- var可以重复定义
- 没有块级作用域，是全局变量

## 数组

```javascript
let 数组名 = [数据1,数据2,...];
let 数组名 = new Array(数据1,数据2,...);
```

**索引号从0开始**

通过`[]`访问



### 数组长度

通过`.length`获得（不需要`()`，是属性不是函数）

比如：

```javascript
let a = 数组名.length;
```

### 数组添加新的元素

```javascript
let arr = [1,2];
arr.push(新数据);//将一个或多个元素添加到数组的末尾，并返回该数组的新长度

arr.unshift(新数据);//将一个或多个元素添加到数组的开头，并返回该数组的新长度
```

### 数组元素的删除

```javascript
arr.pop();//删除最后一个元素，并返回该元素的值

arr.shift();//删除第一个元素，并返回该元素的值

arr.splice(起始索引,删除的个数);//个数不写，默认是指定位置以及之后的都删掉
```



### map方法

map方法可以遍历数组处理数据，并且返回新的数组

```javascript
const newArr = arr.map(function(ele,index){
    return ele + '颜色';//ele是数组元素，index是数组索引号。
    //这句意思是原数组每个元素加上'颜色'字符串
});
```

### join方法

join方法用于把数组中的所有元素转换成一个字符串

是通过参数里面指定的分隔符进行分隔:

- 若是`''`空字符串，则所有元素之间没有分隔符
- 若为空，则元素之间用逗号分隔

```javascript
const arr = ['hello','world'];
console.log(arr.join(''));
//helloworld
console.log(arr.join());
//hello,world
```



使用

## 常量

用`const`定义的变量

```javascript
const a = 10;
```

常量不允许重新赋值，定义的时候必须初始化

## 数据类型

是弱数据类型，只有初始化后才知道是什么数据类型

### 基本数据类型：

在栈中分配内存

#### 数字型number

小数，正数，负数等

#### 字符串型string

用`""`/`''`/\`\` 包裹的数据都叫字符串

可以使用转义符`\`输出引号

嵌套使用可以在字符串中加入引号

`+`可以实现字符串的拼接，也可以实现字符串和其他类型/变量的的拼接



```javascript
let a = "";//空字符串
```

#### 布尔型boolean

`true`

`false`

""，0，undefined，null，NaN转换为布尔型都是false。

其余为true

#### 未定义型undefined

`undefined`

未初始化的变量默认值是`undefined`

可用于检查数据有没有传过来

#### 空型null

`null`代表空，是已经赋值了的

`null`作为尚未创建的对象

### 引用数据类型

在栈中放堆**地址**，堆中存数据。对象，数组为引用数据类型

## 对象

是一个数据结构，包括成员变量（属性）和成员函数（方法），是一种无序的数据集合

比如：

```javascript
let 对象名 = {
	"属性名":属性值,
	"方法名":匿名函数,
	"方法名":function(形参){
	
	}
}
-----------或者----------
let 对象名 = new Object(){
	...
}
```

- 多个属性和方法之间用逗号隔开
- 属性名，方法名用`""`/`''`，也可以省略，除非名称中有特殊符号
- 使用`new`关键字创建对象和不使用`new`关键字有很大的区别。使用`new`关键字可以创建新的对象实例，而不使用`new`关键字可能会导致全局对象的属性被意外修改

### 调用对象属性

可以使用`对象名.属性名`

也可以使用`对象名["属性名"]`来使用，`""`或者`''`都可以

### 在对象外新增一个对象属性

`对象名.新属性名=属性值`

### 在对象外删除对象中属性(一般不允许)

`delete 对象名.属性名`

### 调用对象方法

`对象名.方法名(实参)`

### 遍历对象属性

类似c++，使用`in`

```javascript
for(let key in 对象名){//key为对象中属性名,使用[key]取属性值
	
}
```

> [!WARNING]
>
> （；´д｀）ゞ
>
> 对数组用`for(let key in arr)`遍历，key是从0开始的字符串类型的索引，不推荐这样做



### 内置对象

#### Math

提供一些列做数学运算的方法

含有的方法有：

`random`生成0-1之间的随机数，[0,1)

`ceil`向上取整

`floor`向下取整

`max`

`min`

`pow`

`sqrt`

`abs`



比如：

```javascript
Math.floor(Math.random()*(m-n+1)+n);//生成n-m的随机数
```



## 获取数据类型

`typeof(x)`

`typeof x`

两种都可以，我习惯第一种

## 类型转换

使用表单，prompt获取的数据默认时字符串类型

### 隐式转换

- `+`两边只要有一个是字符串，都会把另一个转成字符串
- 除了`+`以外的算术运算符，比如`-*/`都会将数据转换为数字类型
- `+`作为正号使用，会将数据转换为数字型
- 当数字和字符串比较时，比较运算符（除了`===`）会将字符串转换为数字，然后比较值

### 显式转换

`Number(xxx)`转换为数字型

`parseInt(xxx)`转换为数字型，只保留整数

`parseFloat(xxx)`转换为数字型，保留小数





## 算数运算符

和c++一致

## 运算符优先级

c++一致

## NaN

NaN表示一个计算错误，它是一个不正确或者未定义的数学操作得到的结果，任何对NaN的操作都会返回NaN

NaN不等于任何人，包括自己

## 模板字符串

用于简便地拼接字符串和变量

1. 使用反引号``定义字符串
2. 变量放入${}

比如：

```javascript
let age =18;
document.write(`今年${age}岁了。`);
```

## 赋值运算符

和c++一致

## 自增自减运算符

和c++一致

## 比较运算符

与c++不一致的：

- **`===`判断左右两边是否类型和值都相等**，开发中使用这个
- `!==`不等于，**会比较类型和值**

其余一致

## 逻辑运算符

形式和c++一致，返回值有区别

&&返回第一个假或最后一个真的元素

||返回第一个真或最后一个假的元素



若元素是比较运算符，就返回它的比较结果（true/false）

若元素是true/false，就返回本身

## if函数

和c++一致

## 三元运算符

和c++一致

## switch函数

和c++一致

## while函数

和c++一致

## for函数

和c++一致

## 函数封装

```javascript
function 函数名(参数列表){
	return 返回值
}
```

参数用逗号隔开，可以不写let来定义形参，可以给默认值，不给默认值是undefined

也可以没有return，这时候返回值为undefined

比如：

```javascript
function getSum(x=0,y=0){
	return x+y;
}
```

函数名起名要有意义，遵循小驼峰命令法，前缀应为动词

常见动词：

can：判断是否可以执行某个动作

has：判断是否含有某个值

is：判断是否为某个值

get：获取某个值

set：设置某个值

load：加载某些数据

## 函数调用

和c++一致

## 函数内变量

若函数内部，变量没有定义就赋值，就变成全局变量（不建议）

## 匿名函数

没有名字的函数，无法直接调用

```javascript
function (){

}
```

### 调用方法

#### 函数表达式

将匿名函数赋值给一个变量，通过变量名来进行调用

```javascript
let fn1 = function (形参){

}
----------调用---------
fn1(实参);
```

其实相当于变量名就是函数名

不同点：

1. 有名函数调用可以写到任何位置，包括定义之前
2. 函数表达式只能定义之后使用

#### 立即执行函数

用于避免全局变量之间的污染，将变量转化为局部变量

```javascript
(function (形参){

})(实参);//方法1，会立刻执行匿名函数中的语句


(function (形参){

}(实参))//方法2
```



## 逻辑中断

&&，当左边为false时就退出判断，不执行右边代码

||，当左边为true时就退出判断，不执行右边代码



&&，当两侧都为true，就返回最后一个真值

### 逻辑中断实现函数参数默认值

```javascript
function fn(x,y){
	x= x||0;
	y= y||0;
	...
}
```

## 变量声明

优先用const，若发现需要修改，再改为let

const修饰引用数据类型，只是不允许地址的修改，数据的增删是可以的，但不能用新的引用数据类型覆盖原来的

## Web APIs

使用JavaScript去操作html和浏览器

### DOM文档对象模型

专门用于操作网页内容的功能

#### DOM树

将HTML文档以树状结构表现出来，直观体现标签与标签之间的关系，又称为DOM树

（像遗传图谱）

#### DOM对象

浏览器根据HTML标签生成的JavaScript对象

所有的标签属性都可以在这个对象上找到

修改这个对象的属性会自动映射到标签



核心思想：把网页内容当作对象来处理

document对象是DOM提供的一个对象

网页所有内容都在document对象中

它的属性和方法是用来访问和操作网页内容的

#### 获取DOM对象

选择匹配的**第一个**元素:

`document.querySelecotr('css选择器');`

比如：

```javascript
const box1 = document.querySelecotr('div');
const box2 = document.querySelecotr('.box');
const box3 = document.querySelecotr('#nav');

-------------html-----------------
<div>xxx</div>
<div class="box">xxx</div>
<div id="nav">xxx</div>
```



选择匹配的**多个**元素:

`document.querySelecotrAll('css选择器');`

返回值是一个NodeList 对象集合，有长度有索引号，无法增删功能，可以使用for遍历

#### 操作元素内容

基本语法：`对象.属性=值`



`对象.innerText`获得元素中的文本，不会让=后写的标签生效

`对象.HTML`会让=后写的标签生效

比如：

```JavaScript
xxx.innerHTML = '<strong>111</strong>';
```



#### 操作元素样式

##### style方式

基本语法：`对象.style.样式属性=值`（要加单位）

若样式属性中有-，使用小驼峰命名法就可以

比如：

```javascript
box.style.backgroundColor = 'pink';
```



##### 类名方式

基本语法：`元素.className='新类名'`

比如：

```javascript
div.className = 'box';

-------------css------------
.box {
    ...
}
```

##### classList方式（常用）

以免类名方式覆盖以前的类名，可以使用classList方式追加和删除类名

基本语法：`元素.classList.add('新类名')`

`元素.classList.remove('新类名')`

`元素.classList.toggle('新类名')`切换一个类，已经存在这个类就删掉，没有就加上



### BOM浏览器对象模型

其实就是window对象，叫做浏览器对象模型

window对象是全局对象，使用var定义的在全局作用域的变量和函数都会成为window对象的属性和方法

window对象的属性和方法调用时可以省略`window.`



#### JavaScript执行机制

JavaScript是单线程，但可以使用同步，异步进行多线程



同步任务在主线程（执行栈）上执行

异步任务经过浏览器处理后，添加到任务队列中，通过回调函数执行，如：

- 普通事件：click，resize
- 资源加载：load，error
- 定时器



事件循环：

首先开始执行执行栈中的同步任务，同步任务执行完毕后，按次序读取任务队列中的异步任务加入执行栈，开始执行



#### location对象

拆分并保存了URL地址的各个部分

属性：

`href`用于跳转页面

`search`获取地址中携带的参数，也就是符号?后的部分

`hash`获取地址中携带的参数，也就是符号#后的部分

方法：

` reload`用于刷新当前页面，传入参数true时表示强制刷新

#### navigator对象

记录了浏览器自身的相关信息

属性：

`userAgent`可以检测浏览器的版本及平台

#### history对象

管理历史记录，如浏览器的前进，后退，历史记录

方法：

`back()`后退

`forward()`前进

`go(整数)`前进后退的整合，正数就前进n个，负数就后退n个页面

## 获取表单的值

基本语法`对象.value`

比如：

```javascript
const uname = document.querySelector('input');
console.log(uname.value);
```



对于表单属性中添加就有效果的那些属性：disable，checked，selected，用布尔值表示它的值



比如：

```javascript
const uname = document.querySelector('input');
uname.checked = true;
```

## 自定义属性

在标签的形式为`data-xxx`

在DOM对象的形式为`dataset`

比如：

```javascript
const box = document.querySelector('.box');
box.dataset.id = "1";

------------------html--------------
<div class="box" data-id="10"></div>
```

## 定时器函数

### 间歇函数

定时器可以开启和关闭定时器

开启定时器：

`setInterval(函数,间隔时间)`

- 意思是每隔一段时间调用这个函数，有名函数不要加()
- 间隔时间单位为毫秒
- 返回值是一个定时器id数字

关闭定时器：

`clearInterval(定时器id数字)`



### 延迟函数

让代码延迟执行，只执行一次，返回值是一个定时器id数字

开启：

`setTimeout(函数,等待时间)`

清除：

`clearTimeout(定时器id数字)`

## 事件监听

事件就是系统内发生的动作或事情

比如用户在网页上单机一个按钮



基本语法：

`元素对象.addEventListener('事件类型',函数,[事件流参数])`



### 事件监听版本

L0：会被覆盖

`元素对象.on事件=function(){}`

L2：可以绑定多次，推荐

`元素对象.addEventListener('事件类型',函数)`



### 事件类型

鼠标事件：

`click`鼠标点击

`mouseenter`鼠标经过（推荐）

`mouseover`鼠标经过，有冒泡效果

`mouseout`鼠标离开，有冒泡效果

`mouseleave`鼠标离开（推荐）



焦点事件，表单获得光标：

`focus`获得焦点

`blur`失去焦点



键盘事件：

`Keydown`键盘按下触发

`Keyup`键盘抬起触发



文本事件：

`input`用户输入事件



### 事件对象

事件绑定的函数的第一个参数就是事件对象

一般命名为event,ev,e



比如：

```javascript
元素对象.addEventListener('事件类型',function(event){
    
});
```

对象属性：

`type`获取当前事件类型

`clientX/Y`获取光标相对于浏览器可见窗口左上角的位置

`offsetX/Y`获取光标相对于当前DOM元素左上角的位置

`key`用户按下的键盘键的值



比如：

```javascript
元素对象.addEventListener('事件类型',function(event){
    if(event.key==='Enter'){
        console.log('xxx')
    }
});
```

## 环境对象

在函数内部的this指针（对象），表示当前函数运行时的环境，事件监听时指向函数的调用者，普通函数指向浏览器窗口window

比如：

```javascript
function fn(){
    console.log(this);
};

btn.addEventListener('click',function(){
    this.style.color = 'red';
});
```



## 回调函数

函数a作为参数传入函数b，函数a为回调函数



## 事件流

当一个元素接收到一个事件（如点击或按键）时，这个事件不仅仅只会在这个元素上触发，还会在这个元素的父元素、父元素的父元素，一直到最顶层的文档对象上触发。

事件流包含以下三个阶段：

1. **事件捕获阶段**：事件从文档的根节点向下传播到目标元素，途径的每一个节点都会触发该事件的捕获处理函数（如果有的话）。
2. **目标阶段**：事件到达目标元素，触发目标元素上的事件处理函数。
3. **事件冒泡阶段**：事件从目标元素开始向上回传到文档的根节点，途径的每一个节点都会触发该事件的冒泡处理函数（如果有的话）。



可以使用`addEventListener`方法来为元素添加事件处理函数，并通过该方法的第三个参数来指定事件处理函数是在捕获阶段还是冒泡阶段触发。例如：

```javascript
// 在捕获阶段处理点击事件
element1.addEventListener('click', function(event) {
    console.log('捕获阶段');
}, true);

// 在冒泡阶段处理点击事件，是默认值
element2.addEventListener('click', function(event) {
    console.log('冒泡阶段');
}, false);
```

在这个例子中，`element1`的点击事件处理函数会在捕获阶段触发，而`element2`的点击事件处理函数会在冒泡阶段触发。



### 阻止冒泡

基本语法：

`事件对象.stopPropagation()`

可以阻断事件流的传播，在冒泡和捕获阶段都有效

比如：

```javascript
element1.addEventListener('click', function(event) {
    console.log('捕获阶段');
    event.stopPropagation();
});
```



## 解绑事件

on事件：赋值为null

addEventListener：使用`removeEventListener('事件类型',函数[,事件流参数])`

> [!CAUTION]
>
> （＞人＜；）
>
> 匿名函数无法解绑

## 事件委托

利用事件冒泡机制，减少注册次数

给父元素注册事件，当触发子元素时，会冒泡到父元素身上，从而触发父元素的事件



比如：

```javascript
const ul = document.querySelector('ul');
ul.addEventListener('click',function(event){
    alert('xxx');
    console.log(event.target.tagName);
});
```

点击li会触发ul的事件，通过event.target可以得到真正触发事件的元素

## 阻止元素默认行为

基本语法：addEventListener函数中

`event.preventDefault()`

## 页面加载事件

加载外部资源（如图片，外联css和JavaScript等）完毕时触发的事件

事件名：load

比如：

```javascript
window.addEventListener('load',function(){
    ...
});
```

等待页面所有资源加载完毕，就会执行回调函数



也可以是某个资源加载完毕后

比如：

```javascript
img.addEventListener('load',function(){
    ...
});
```

等待图片加载完毕，就会执行回调函数



### 只需在HTML文档加载解析之后执行

无需加载外部资源

基本语法：

`document.addEventListener('DOMContentLoaded',function(){})`

## 页面滚动事件

滚动条在滚动时持续触发的事件

事件名：scroll

比如：

```javascript
window.addEventListener('scroll',function(){
    ...
});
```

监听整个页面滚动



属性：

`scrollLeft`获取元素内容往左滚动的距离，可以读写

`scrollTop`获取元素内容往上滚动的距离，可以读写

比如：

```javascript
window.addEventListener('scroll',function(){
    const n = document.documentElement.scrollTop;
});
```



## 页面尺寸事件

窗口尺寸改变时触发事件

事件名：resize

比如：

```javascript
window.addEventListener('resize',function(){
    ...
});
```

属性：

`clientWidth`获取屏幕宽度，不包含边框，外边距，滚动条

`clientHeight`获取屏幕高度，不包含边框，外边距，滚动条



## 元素自身尺寸

`offsetWidth`获取元素自身宽度，包含元素设置的宽度，内边距，边框

`offsetHeight`获取元素自身高度，包含元素设置的高度，内边距，边框

> [!CAUTION]
>
> ヾ(≧▽≦*)o
>
> 若盒子是隐藏的，获取的结果是0



## 元素在页面中的位置

`offsetLeft`获取元素距离自己最近一级带有定位祖先元素的左边距离，只读

`offsetTop`获取元素距离自己定位父级元素最近一级带有定位祖先元素的上边距离，只读

## 日期对象

得到当前系统时间

获得当前时间：

```javascript
const date = new Date()
```



指定时间

```javascript
const date = new Date('2045-1-4 08:30:00')
```



对象方法：

`getFullYear()`获得四位数年份

`getMonth()`获得取值为0-11的月份

`getDate()`获得月份中的一天

`getDay()`获得取值为0-6的星期

`getHours()`获得取值为0-23的小时

`getMinutes()`获得取值为0-59的分钟

`getSeconds()`获得取值为0-59的秒钟



### 时间戳

指的是1970年1月1日00分00秒到现在的毫秒数，用来实现倒计时效果。

1. 将来时间戳-现在时间戳=剩余时间毫秒数
2. 剩余时间毫秒数转换为剩余时间的年月日分秒



使用getTime()方法

```javascript
const date = new Date();//必需
console.log(date.getTime());
console.log(date.getTime('2045-1-4 08:30:00'));
```



使用+new Date()方法

```javascript
console.log(+new Date());
console.log(+new Date('2045-1-4 08:30:00'));
```



使用Date.now()方法，但只能得到当前的时间戳，前两种可以返回指定时间的

```javascript
console.log(Date.now());
```



## 节点操作

### DOM节点

DOM树种每一个内容都成为DOM节点，包括：

- 元素节点：所有的标签
  - html为根节点
- 属性节点：所有的属性
- 文本节点：所有的文本
- 其他



### 查找节点

父节点查找：

`子元素.parentNode`

返回最近一级的父节点，找不到返回null。

可以叠加使用



子节点查找：

`父元素.childNode`获得所有子节点

`父元素.children`仅获得所有元素节点，返回的是个伪数组



兄弟节点查找：

`节点.nextElementSibling`获得下一个兄弟节点

`节点.previousElementSibling`获得上一个兄弟节点

### 增加节点

创建节点，然后将新节点放入指定元素内部

`document.createElement('标签名');`创建节点

`父元素.appendChild(要插入的元素);`插入到父元素的最后

`父元素.insertBefore(要插入的元素，另某个元素);`插入到父元素中某个子元素的前面



比如：

```javascript
const ul = document.querySelector('ul');
const li = document.createElement('li');
ul.insertBefore(li,ul.children[0]);//插入到第一个li之前
```

### 复制节点

`元素.cloneNode(布尔值);`

布尔值若为true，表示复制时会将后代节点一起复制

若为false，表示不复制后代节点，默认为false

### 删除节点

删除元素必须通过**父元素**删除

`父元素.removeChild(子元素);`

## 移动端事件

触摸事件：

`touchstart`触摸到一个DOM元素时触发

`touchmove`在一个DOM元素上滑动时触发

`touchend`在一个DOM元素上移开时触发

## 本地存储

数据存储在用户浏览器中，页面刷新不丢失

有两种存储：

### localStorage

- 可以将数据永久存储到本地，除非手动删除
- 可以同一浏览器，多窗口共享数据
- 以键值对的形式存储

存储/修改数据：

`localStorage.setItem(key,value);`

获取数据：

`localStorage.getItem(key);`

删除数据：

`localStorage.removeItem(key);`

### sessionStorage

- 生命周期为关闭浏览器窗口
- 同一窗口下共享数据
- 以键值对的形式存储
- 用法和localStorage基本相同



### 存储复杂数据类型

本地只能存储字符串，无法存储复杂数据类型

需要将复杂数据类型转换成JSON字符串，再存储到本地

基本语法：

`JSON.stringify(复杂数据类型);`

比如：

```javascript
const obj = {
   	uname:'pink',
    age:18,
    gender:'女'
}

localStorage.setItem('obj',JSON.stringify(obj));
```

JSON对象，也是键值对形式，属性和字符串值都带有双引号

比如：

```json
{"uname":"pink","age":18,"gender":"女"}
```



JSON对象转换为对象：

`JSON.parse(JSON对象);`

## 正则表达式

用于匹配字符串中字符组合，在JavaScript中，正则表达式也是对象

定义正则表达式有两种方式

方式1：

1. `const 变量名 =/表达式/;`
2. `表达式的变量名.test(被检测的字符串)`返回true或是false

方式1：

1. `const 变量名 =/表达式/;`
2. `表达式的变量名.exec(被检测的字符串)`匹配成功返回的是一个数组，匹配失败返回null

### 元字符

更强大，灵活的匹配功能

比如：[a-z]

#### 边界符

表示位置，开头和结尾，必须用什么开头，用什么结尾

- `^` 表示匹配行首的文本，以谁开始
- `$`表示匹配行尾的文本，以谁结束
- 一起使用表示精确匹配

比如：

```javascript
console.log(/^哈/.test('二哈'));//false
console.log(/^哈$/.test('哈'));//true
```



### 量词

表示重复次数，匹配前面一个的字符

`*`重复零次或多次

`+`重复一次或多次

`?`重复零次或一次

`{n}`重复n次

`{n,}`重复n次或更多次

`{n,m}`重复n到m次

比如：

```javascript
console.log(/^哈{1}$/.test('哈'));//true
```



### 字符类

（1）[]匹配，只要字符串中包含[]中任意一个字符都可以

比如：

```javascript
[a-zA-Z0-9_]
[1-9][0-9]{4,n}
```

`^`表示取反

（2）.匹配，匹配除换行符之外的任何单个字符

（3）预定义，某些常见模式的简写

`\d`相当于[0-9]

`\D`相当于[\^0-9]

`\w`匹配任意字母数字和下划线

`\W`上面的取反

`\s`匹配空格，换行符，制表符等

`\S`上面的取反

### 修饰符

修饰正则表达式的细节，比如是否支持大小写，多行匹配等

基本语法：

`/表达式/修饰符`



`i`表示不区分大小写

`g`表示匹配所有满足正则表达式的结果

可以一起使用

比如：

比如：

```javascript
console.log(/^哈{1}$/ig.test('哈'));
```

## 字符串替换

基本语法：

`字符串.replace(/正则表达式（被替换的文本）/,'替换的文本');`

## 块作用域

和c++意思一致

const，let声明的变量会产生块作用域，var不会产生块作用域

不同块作用域之间的变量互相访问，所以推荐const和let

## 全局作用域

`<script>`标签里和.js文件的最外层就是全局作用域

为window对象动态添加的属性默认也是全局的

函数中未使用关键字进行声明的变量也是全局的

## 作用域链

本质是底层的变量查找机制

函数在执行时，会优先查找当前函数作用域中查找变量

若找不到，会逐级查找父级作用域直到全局作用域

子作用域能访问父作用域，父作用域无法访问子作用域

## 垃圾回收机制

简称GC

JavaScript中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收



全局变量在关闭页面时回收

局部变量超过作用域会被自动回收

会出现内存泄漏



栈和堆空间分配机制与c++一致，复杂数据类型放在堆中

若堆内存程序员不自己释放，由垃圾回收器来回收。

### 引用计数法

看一个对象是否有指向它的引用，没有就回收内存

同c++共享指针

但由于没有weakptr，所以无法解决循环引用问题

### 标记清除法

是将不再使用的对象定义为无法到达的对象

从全局（根部）对象出发，定时扫描内存中的对象，凡是能从根部到达的对象，都是还需要使用的。无法到达的对象会进行回收

## 闭包

一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域

闭包=外层函数的变量+内层函数

用于在函数外部访问函数内部的变量，也就是让数据私有，无法在外部修改数据

比如：

```javascript
function outer(){
    const a=1;
    function fn(){
        console.log(a);
    }
    return fn;
}
const fun = outer();
fun();
```

但会有内存泄漏问题

## 变量提升

使用var声明的变量可以在变量声明之前访问，变量的值为undefined

相当于把所有var声明的变量提升到**当前作用域**的最前面，但是只提升声明，不提升赋值语句

## 函数提升

函数声明前可以被调用

相当于把函数声明提升到当前作用域的最前面，但是只提升声明，不提升函数调用

比如：

```javascript
myFunction();  // 输出：Hello World!

function myFunction() {
  console.log("Hello World!");
}
```

但是**函数表达式**不存在提升，必须声明和赋值之后再调用

比如：

```javascript
myFunction();  // 报错：Uncaught ReferenceError: myFunction is not defined

const myFunction = function() {
  console.log("Hello World!");
};
```

## 动态参数

`arguments`是函数内部内置的伪数组变，只存在在函数中，包含了调用函数时传入的所有实参

比如：

```javascript
function sum(){
    let ans =0;
    for(let i=0;i<arguments.length;i++){
        ans +=arguments[i];
    }
    console.log(ans);
}

sum(5,10);
sum(5,10,15);
```

## 剩余参数

`...xxx`可以将不定数量的参数表示为一个数组xxx

比如：

```javascript
function sum(a,b,...arr){
    console.log(arr);
}

sum(5,10);
sum(5,10,15);
```

`..xxx`置于最末函数形参之前，用于获取多余的实参，是真数组

## 展开运算符

`...`就是展开运算符，当用在数组中时，展开运算符可以将数组的元素展开为单独的元素。

比如：

```javascript
let first = [1, 2, 3];
let second = [4, 5, 6];

let combined = [...first, ...second];  // [1, 2, 3, 4, 5, 6]

let original = [1, 2, 3];
let copy = [...original];  // 创建original的一个浅拷贝

function sum(x, y, z) {
  return x + y + z;
}

let numbers = [1, 2, 3];
console.log(sum(...numbers));  // 等同于调用 sum(1, 2, 3)
```



展开运算符也可以用于对象字面量，用于复制对象的属性或合并多个对象。这在处理对象时提供了一种非常便捷的方式来合并或修改对象的属性。

比如：

```javascript
let obj1 = { a: 1, b: 2 };
let obj2 = { b: 3, c: 4 };

let combinedObj = { ...obj1, ...obj2 };  // { a: 1, b: 3, c: 4 }

let obj = { a: 1, b: 2 };

let newObj = { ...obj, b: 3, c: 4 };  // { a: 1, b: 3, c: 4 }
```



注意：

- 展开运算符提供的是浅拷贝。如果原始对象包含嵌套对象，那么嵌套对象的引用仍然会保持不变。
- 在使用对象展开时，后面的属性会覆盖前面的同名属性。
- 展开运算符只能用于可迭代的对象，如数组，或者可枚举属性的对象。

## 箭头函数

用于替代匿名函数，更短且不绑定this

基本语法：

`const fn =(形参) =>{`

`}`

比如：

```javascript
//原函数表达式
const fn = function(形参){
    
}
//箭头函数用于函数表达式
const fn =(形参) => {
    
}
//只有一个参数，小括号可以省略；函数体只有一行代码，大括号和return可以省略
const fn = 一个形参 => console.log(x);
const fn = x => x+x;
const fn = x =>({uname:x});//返回对象需要加小括号
```



**箭头函数没有动态参数，但有剩余参数**

箭头函数不会创建自己的this，只会沿用上一层作用域链的this，DOM事件中不推荐使用箭头函数

## 数组解构

用于将数组的元素快速批量赋值给一系列变量

比如：

```javascript
const [a,b,c] = [1,2,3];
console.log(a);
a=4;
console.log(b);
console.log(c);

//也可用于快速交换变量值
[b,a] = [a,b];
```



（1）当变量多，数组值少时：多的变量的值是undefined

（2）当变量少，数组值多：不影响。可用剩余参数来接收

比如：

```javascript
const [a,...b] = [1,2,3];
```

（3）变量可以设置默认值

比如：

```javascript
const [a='4',b='5'] = [1];
```

（4）可以按需赋值

比如：

```javascript
const [a,b,,c] = [1,2,3,4];
```

（5）多维数组也支持

比如：

```javascript
const [a,[b,c,d]] = [1,[2,3,4]];
const [a,b] = [1,[2,3,4]];
```

## 对象解构

用于将对象的属性和方法快速批量赋值给一系列变量

比如：

```javascript
const user = {
    name:'小明',
    age:18
};
const {name,age} = user;
```



对象属性的值会被赋予与属性名相同的变量。

找不到相同名字的属性，变量赋值为undefined



当属性名和外面的变量名字冲突时，可以改解构时的变量名

比如：

```javascript
const user = {
    name:'小明',
    age:18
};
const {name:username,age} = user;
```



### 对象数组解构

比如：

```javascript
const user = [
    {
    name:'小明',
    age:18
	},
    {
    id:1
    }
];
const [{name,age},{id}] = user;
```

### 多级对象解构

比如：

```javascript
const user = {
    name:'小明',
    age:18
    family:{
    	son:'1'
	}

};
const {name,age,family:{son}}= user;
```

## forEach函数

用于将数组中的每个元素传递给回调函数

`数组名.forEach(function(当前数组元素,当前元素索引号){`

​	`函数体`

`})`

比如：

```javascript
const arr = ['red','blue','green'];
arr.forEach(function(item,index){
    console.log(item);
    console.log(index);
})
```

主要用于遍历数组，不返回新数组。

参数中索引号可以不写

## 创建对象

### 利用对象字面量创造对象

```javascript
const obj = {
    uname:'小明'
}
```

### 利用new Object创造对象

```javascript
const obj = new Object({uname:'pink'})
```

### 利用构造函数创造对象

命名只能以大写字母开头，只能通过new来执行

```javascript
function Point(x,y){
    this.x = x;
    this.y = y;
}
const tigerPoint = new Point(3,5);
const cowPoint = new Point(5,5);
const grassPoint = new Point(7,5);
```



步骤：

1. 创建新对象
2. 构造函数this指向新对象
3. 执行构造函数代码，修改this，添加新属性
4. 返回新对象

构造函数创建的对象叫实例对象，实例对象的成员叫实例成员（动态属性，动态方法）

构造函数里的属性和方法叫静态成员（静态属性和静态方法）

## 包装

JavaScript在底层将简单数据类型包装成引用数据类型

## 内置构造函数

引用类型：Object，Array，RegExp，Date等

包装类型：String，Number，Boolean

### Object静态方法

`const arr = Object.keys(对象名)`

获得对象中所有属性名，返回一个数组



`const arr = Object.values(对象名)`

获得对象中所有属性值，返回一个数组



`Object.assign(另一个对象名,对象名/{}对象)`

拷贝数组，经常使用场景为为对象添加属性

比如：

```javascript
const obj = {uname:'pink',age:18};
Object.assign(obj,{gender:'男'});
```

### Array静态方法

forEach

遍历数组，不返回数组



filter

过滤数组，返回新数组



map

迭代数组，返回新数组



reduce

累计器，返回累计处理后的结果

基本语法：

`arr.reduce(function(上一次的值,当前值){},初始值)`

比如：

```javascript
const arr = [1,5,8];
const total = arr.reduce(function(prev,current){
    return prev+current;
},10)//有初始值会加上初始值

const total= arr.reduce((prev,current)=>prev+current
,10)//箭头函数
```

reduce执行过程：

1. 如果没有起始值，则初始的上一次值是数组的第一个元素的值
2. 每一次循环，把返回值作为下一次循环的上一次值
3. 如果有起始值，则起始值为上一次值



join

拼接字符串并返回

find
